<!DOCTYPE html>
<html><head><meta content="width=device-width, initial-scale=1" name="viewport"><meta charset="utf-8"><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3VM2LWXJF8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3VM2LWXJF8');
</script>
<link href="resource/site/k.png" rel="icon" type="image/x-icon"><link href="resource/site/css/layout.css" rel="stylesheet" type="text/css"><link href="resource/site/css/header.css" rel="stylesheet" type="text/css"><link href="resource/site/css/footer.css" rel="stylesheet" type="text/css"><link href="resource/site/css/article.css" rel="stylesheet" type="text/css"><link href="resource/site/css/anchor.css" rel="stylesheet" type="text/css"><link href="resource/site/css/highlight_fragment.css" rel="stylesheet" type="text/css"><title>블로그 프로젝트를 위해 작성한 How to Solve it 식 설계 표현</title><link crossorigin="anonymous" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/agate.min.css" integrity="sha512-wI7oXtzNHj/bqfLA3P6x3XYbcwzsnIKaPLfjjX8ZAXhc65+kSI6sh8gLOOByOKImokAjHUQR0xAJQ/xZTzwuOA==" referrerpolicy="no-referrer" rel="stylesheet"></head><body><header class="container"><hr><div class="site-title"><a class="only-cursor" href="/">KUR Creative</a></div><hr><nav class="navigation"><a class="only-cursor" href="archive">archive</a><a class="only-cursor" href="series">series</a><a class="only-cursor" href="tags">tags</a><a class="only-cursor" href="subscribe">subscribe</a><a href="https://www.google.com/search?q=site%3Ablog.kurcreative.com+공사중.."><img height="20px" src="resource/site/search.png" width="20px"></a></nav><hr></header><article class="container"><a class="series-top-link" href="series#Blog프로젝트">Blog프로젝트</a><h1>블로그 프로젝트를 위해 작성한 How to Solve it 식 설계 표현</h1><p>설계 표현에 대해서<a href="kur2103122226.+.(OLD)설계 표현과 설계 활동에 대한 연구=;= 쓰라는 논문은 안 쓰고!">개삽질을 하던 때</a>가 있었다. 그런 무수한 삽질로부터 얻은 결론은?</p>
<p>혼자 하는 프로젝트면</p>
<ol>
<li>기본적으로 <mark>처음에는 설계를 작성하지 마라</mark></li>
<li>전체 설계를 작성할 생각이 들었다면 작성하지 마라</li>
</ol>
<p>왜냐면 처음 할 때는 아무리 뻔한 프로젝트라도 설계가 미친듯이 변하기 마련이라 그렇다.<br>
PoC를 하면서 어느 정도 안정이 되어갈 때 쯤 아주 아주 조금씩 설계 표현을 작성해야 한다.</p>
<p>진짜 필요할 때쯤</p>
<ol>
<li>3번쯤 생각해보고 정말 필요하면 <strong>하나의 문제에 대해서만</strong> 작성한다</li>
<li>전체에 대한 설계는 가능하면 만들지 않는다.</li>
</ol>
<p>그래서 블로그 프로젝트를 할 때, 정말로 까다로운 문제에 대해서만 <a href="https://en.wikipedia.org/wiki/How_to_Solve_It">How to Solve it</a> 식으로 설계 표현을 작성했다.</p>
<h2 id="How-to-Solve-it-식-설계-표현" tabindex="-1"><a class="only-cursor" href="#How-to-Solve-it-식-설계-표현">How to Solve it 식 설계 표현</a></h2>
<ul>
<li>문제를 분석하고, 문제의 요소를 <strong>미지/조건/사실</strong> 로 나눈다.</li>
<li>마지막으로 <strong>해답을 여러개</strong> 넣고 <strong>트레이드오프</strong>해 본다.</li>
<li>각 문장에 대한 인덱스는 ref가 필요하며 넣는다. (안 넣어도 된다)</li>
<li>그 외에 걍 대충 알아서 해라. 중요한 건 <b><u>간결함</u></b>이지 형식이 아니다.<br>
오직 간결한 설계 표현만이 살아 남는다.</li>
</ul>
<p>다음은 블로그 프로젝트를 하면서 작성한 설계표현들이다</p>
<h3 id="무엇을-만들고-무엇을-leverage할-것인가?" tabindex="-1"><a class="only-cursor" href="#무엇을-만들고-무엇을-leverage할-것인가?">무엇을 만들고 무엇을 leverage할 것인가?</a></h3>
<blockquote>
<p><strong>미지 Unknowns</strong><br>
1 무엇을 만들 것인가?<br>
2 무엇을 leverage할 것인가?</p>
<p><strong>조건 Conditions</strong><br>
네이버 블로그 서비스 수준의 편의성<br>
1 기기 Sync: 컴, 폰에서 간단히 글 쓰고 조작할 수 있어야 한다<br>
2 md로 작성한 글을 웹으로 수월하게 보여줄 수 있어야 한다<br>
3 md를 원하는 형태로 변경할 수 있어야 한다</p>
<p>4 포스트 히스토리를 저장할 수 있다<br>
5 SyncThing에 의해 발생하는 찌꺼기 파일(conflict..)은 사용자에게 보이지 않아야 한다</p>
<p><strong>사실 Facts</strong></p>
<p><strong>물음 Questions</strong><br>
AWS Lambda로 nginx(Publisher)를 대신할 수 있을까? 혹은 그 외 저렴하고 안정적인 정적 서빙 서비스는?<br>
Syncthing을 클라우드에서 더 저렴하게 사용하려면?</p>
<p><strong>해답</strong><br>
poc0<br>
Syncthing, Obsidian을 leverage -&gt; C1</p>
<p>poc1<br>
Publishable 도입</p>
<p>poc2 (maybe 0.0.1)<br>
md를 html로 바꾸는 모듈(Updater)만 만든다 -&gt; C3<br>
updater에서 html 폴더가 업데이트될 때마다 html 폴더와 md 폴더를 깃 커밋 하여 히스토리 관리하기</p>
<p>날로 먹는 것</p>
<ul>
<li>에디터: Obsidian</li>
<li>데이터 Sync: Syncthing</li>
<li>프론트엔드 서버: Nginx 정적 파일 서빙에 의존 -&gt; C2</li>
</ul>
<p>만드는 것</p>
<ul>
<li>md를 html로 바꾸는 변환기(converter) -&gt; C3</li>
<li>Sync되는 md, 리소스 폴더로부터 변환한 html 폴더 관리(updater, C/R/U/D)</li>
</ul>
</blockquote>
<p>가장 중요한 문제이자 내 블로그의 가장 독특한 특징 - <strong>날로먹기</strong> 에 대한 문제 시트다.<br>
마지막 해답인 poc2를 보면 결국 죄다 날로 먹고 직접 만드는 건 마크다운 파서와 상태 관리 로직이 끝이다.</p>
<p>이렇게 날로 먹기 때문에 짧은 시간 안에 매우 품질(성능, 확장성, 등)이 좋은 프로그램을 만들 수 있었다.</p>
<h3 id="배포" tabindex="-1"><a class="only-cursor" href="#배포">배포</a></h3>
<blockquote>
<p><strong>미지 Unknowns</strong><br>
U1 배포 전략?</p>
<ul>
<li>U1a 배포? - nginx(<a href="https://github.com/nginx-clojure/nginx-clojure">https://github.com/nginx-clojure/nginx-clojure</a>) -&gt; nginx에서 https하는 법?</li>
<li>U1b 자동화? - github action(애초에 private이라..)</li>
<li>c deps.edn 사용법? (uberjar 생성, dev/test deps 격리 등등)</li>
</ul>
<p><strong>조건 Conditions</strong><br>
C1 항상 https 연결이 가능해야 한다<br>
2 보안 - 뚫기 어렵고 털려도 피해가 없어야 한다<br>
3 간단함 - 방법을 까먹어도 간단히 처리할 수 있고 다시 보면 알 수 있어야 한다<br>
4 자동화 - 간단한 명령으로 배포를 수행할 수 있다</p>
<p>5 SyncThing을 처리할 수 있어야 한다<br>
6 Lightsail에서 작동해야 한다</p>
<p>7 https로 볼 수 있어야 한다<br>
8 유지 비용은 쌀수록 좋다</p>
<p><strong>사실 Facts</strong><br>
certbot을 쓰면 간단히 https를 띄울 수 있다</p>
<p>f1 github action을 쓰면 yaml에 aws콘솔을 쓰는 방식으로 ls 배포를 자동화할 수 있다: <a href="https://brewagebear.github.io/ligthsail-ci-cd-setup/">https://brewagebear.github.io/ligthsail-ci-cd-setup/</a></p>
<ul>
<li>보아 하니 터미널이 있고 yaml에 명령어를 적는 방식이라 못하는 게 없어 보인다</li>
<li>release가 있을 때만 작동하게 할 수 있나? 가능</li>
</ul>
<p>f2 nginx는 워커 프로세스(서버) 여럿을 만들 수 있다</p>
<ul>
<li>nginx 밖에서 업데이터(파일 수정) 프로세스를 생성해야 한다.</li>
<li>업데이터 disable/enable할 수 있거나 jar를 따로 만들거나.</li>
</ul>
</blockquote>
<p>이건 해답을 미지 바로 옆에다 써버려서 딱히 해답 섹션이 없다. 그래도 된다. 형식은 중요하지 않다..</p>
<h3 id="poc2-Updater" tabindex="-1"><a class="only-cursor" href="#poc2-Updater">poc2 Updater</a></h3>
<blockquote>
<p>전제조건 &lt;- <a href="kur-blog.무엇을 만들고 무엇을 leverage할 것인가q">kur-blog.무엇을 만들고 무엇을 leverage할 것인가q</a></p>
<ul>
<li>md -&gt; html 변환기와 C/R/U/D 업데이터만 만든다</li>
<li>정적 파일 서빙에 의존한다</li>
</ul>
<p><strong>미지 Unknowns</strong><br>
1 코드의 구조<br>
2 페이지들을 다형성으로 묶는다/묶지 않는다<br>
3 데이터 처리 공정</p>
<p><strong>조건 Conditions</strong><br>
1 md가 삭제되면 변환 결과인 html도 삭제되어야 함 &lt;- F1<br>
2 post가 private이 되어도 변환 결과인 html은 삭제되어야 함</p>
<p>3 고쳐야 하는 코드를 찾기 쉬워야 한다<br>
3a 각각 하나의 페이지와 관련된 로직은 각각 한 곳에 모여있어야 함<br>
3b 여러 페이지나 로직이 공유하는 로직은 공유 ns에 모여있어야 함</p>
<p><strong>사실 Facts</strong><br>
0 정적 파일 서빙에 의존하므로, updater만 만들면 된다<br>
1 서빙되는 정적 파일이 존재 하는 것이 public이다<br>
2 페이지마다 업데이트 조건이 다르다<br>
3 차후 글에 tag를 달고, tag별로 모아 보는 페이지를 넣을 수 있다</p>
<p>4 어떤 페이지(home, tags)들은 다른 페이지(post)에 의존한다</p>
<p><strong>해답</strong><br>
U2: 안 쓴다!</p>
<ul>
<li>안쓴다 근거
<ul>
<li>인터페이스가 동일하지도 않다(post 외에는 state를 볼 뿐 경로는 필요 없다)</li>
<li>post를 제외한 페이지들은 다른 페이지에 의존적이어서 write 순서가 중요해질 수 있다</li>
<li>state가 오로지 post로만 구성된다면 Page 엔티티가 딱히 필요하지 않다: state에 모든 Page를 모아둘 필요가 없다.</li>
<li>다형성으로 묶을 경우 유연성이 떨어질 수 있다. state가 Record로 이뤄진다는 주박에서 벗어나니 코드가 더 자유롭다.</li>
</ul>
</li>
<li>쓴다 근거
<ul>
<li>페이지라는 공통점, 엔티티 = 페이지 하나</li>
<li>공통적으로 write? write! 가 필요</li>
<li>코드가 op로 구분되어 있어 보기 편함</li>
</ul>
</li>
</ul>
<p>U3: md-dir =&gt; posts,happends -&gt; site =&gt; html-dir</p>
<ul>
<li>poc1과 차이점
<ul>
<li>posts: post만 포함한다.</li>
<li>site: posts 외 다른 페이지까지 포함(아마 seq) html-dir에 write!</li>
<li>post의 C/R/U/D는 old, new state와 happend를 보고 판단</li>
</ul>
</li>
<li>poc1과 공통점
<ul>
<li>기존 state처럼 posts는 md-dir  변경 시 매번 생성(happend도)</li>
</ul>
</li>
</ul>
</blockquote>
<p>이 문제 시트는 위 문제: <a href="#무엇을 만들고 무엇을 leverage할 것인가?">#무엇을 만들고 무엇을 leverage할 것인가?</a>의 해답에 의존적이다. 이 문제는 leverage 문제가 결국 다른 해답을 내놓게 되면 아무런 쓸모가 없어질 수 있다. 그런 낭비에 대비해야하기 때문에, 설계 표현은 간결해야 하고, 되도록 그냥 안 쓰는 게 낫고.. 정말 필요할 때만 써야 한다.</p>
<p>U1 코드 구조에 대해서는 아예 해답을 작성하지 않았다. 코드 구조처럼 구체적이고 변경이 많은 건 사실 미지로도 넣지 않는 것이 좋다.</p>
<p>이 문서에서는 실제로 여러 해답 간의 트레이드 오프를 보여준다. 여러 페이지(<a href="https://blog.kurcreative.com">home</a>, <a href="https://blog.kurcreative.com/archive">archive</a> 등) 엔티티가 상속하는 Publishable 프로토콜을 추가할 것인가? 그러지 않을 것인가?<br>
갓-바와 OOP에 뇌가 절여진 사람이라면 묻지도 따지지도 않고 Publishable 인터페이스를 추가하고 각 페이지를 인터페이스 구체화를 통해 구현했을 것이다. 하지만 나는 poc1에서 그거 추가했었는데 별로 재미를 못 봤었다.<br>
그런 경험과 그 외의 지식까지 곁들여서 트레이드 오프를 해 보았고, 결국 Publishable 없이 구현하기로 결정한다.(문제 시트에 결국 무엇을 결정했는지는 나오지 않는다. 그런 거 필요 없다!)</p>
<h4 id="설계-그대로-프로그래밍하기" tabindex="-1"><a class="only-cursor" href="#설계-그대로-프로그래밍하기">설계 그대로 프로그래밍하기</a></h4>
<p>U2와 U3의 결정이 합쳐져, 매우 깔끔하고 확장하기 쉬운 유연한 구조로 사이트를 구현할 수 있었다.</p>
<p><code>src/clj/kur/blog/updater.clj</code></p>
<pre><code class="hljs language-clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">classify-posts</span>
  <span class="hljs-string">&quot;Return post groups classified by file system change(delete, write, as-is)
   NOTE: unchanged(post)s inherit loaded text from old-posts.&quot;</span>
  [old-posts now-posts]
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [mergeds
        (<span class="hljs-name"><span class="hljs-built_in">vec</span></span> (<span class="hljs-name">post-diff/merge-and-assoc-happened</span> old-posts now-posts))

        {unchangeds <span class="hljs-literal">true</span> changeds <span class="hljs-literal">false</span>}
        (<span class="hljs-name">group-by</span> #(<span class="hljs-name"><span class="hljs-built_in">=</span></span> <span class="hljs-symbol">::post-diff/as-is</span> (<span class="hljs-symbol">:happened</span> %)) mergeds)

        {to-deletes <span class="hljs-symbol">::post/delete!</span><span class="hljs-punctuation">,</span> to-writes <span class="hljs-symbol">::post/write!</span>}
        (<span class="hljs-name">group-by</span> post/how-update-html changeds)

        map-rm-hap (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [posts] (<span class="hljs-name"><span class="hljs-built_in">map</span></span> #(<span class="hljs-name"><span class="hljs-built_in">dissoc</span></span> % <span class="hljs-symbol">:happened</span>) posts))]
    {<span class="hljs-symbol">:unchangeds</span> (<span class="hljs-name">map-rm-hap</span> unchangeds)
     <span class="hljs-symbol">:to-deletes</span> (<span class="hljs-name">map-rm-hap</span> to-deletes)
     <span class="hljs-symbol">:to-writes</span> (<span class="hljs-name">map-rm-hap</span> to-writes)}))

(<span class="hljs-keyword">defn</span> <span class="hljs-title">site</span>
  <span class="hljs-string">&quot;Return commands to maintain html files of site
   commands are [[f &amp; args]*]&quot;</span>
  [unchanged-posts post-to-delete loaded-posts-to-write html-dir]
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [public-posts (<span class="hljs-name"><span class="hljs-built_in">sort-by</span></span> <span class="hljs-symbol">:id</span> #(<span class="hljs-name"><span class="hljs-built_in">compare</span></span> %<span class="hljs-number">2</span> %<span class="hljs-number">1</span>)
                              (<span class="hljs-name"><span class="hljs-built_in">concat</span></span> unchanged-posts
                                      loaded-posts-to-write))
        html-path #(<span class="hljs-name"><span class="hljs-built_in">str</span></span> (<span class="hljs-name">fs/path</span> html-dir %))]
    (<span class="hljs-name"><span class="hljs-built_in">concat</span></span>
     (<span class="hljs-name"><span class="hljs-built_in">map</span></span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [post]
            [spit (<span class="hljs-name">html-path</span> (<span class="hljs-name">post/html-file-name</span> post))
             (<span class="hljs-name">look-post/html</span> (<span class="hljs-name">post/title-or-id</span> post) (<span class="hljs-symbol">:text</span> post))])
          (<span class="hljs-name"><span class="hljs-built_in">remove</span></span> policy/admin-post? loaded-posts-to-write))
     [[spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;404.html&quot;</span>) (<span class="hljs-name">look-error/page-404</span> public-posts)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;50x.html&quot;</span>) (<span class="hljs-name">look-error/page-50x</span> public-posts)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;home.html&quot;</span>) (<span class="hljs-name">look-home/html</span> public-posts)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;archive.html&quot;</span>) (<span class="hljs-name">look-archive/html</span> public-posts)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;subscribe.html&quot;</span>) (<span class="hljs-name">look-subscribe/html</span>)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;tags.html&quot;</span>) (<span class="hljs-name">look-tags/html</span> public-posts)]
      [spit (<span class="hljs-name">html-path</span> <span class="hljs-string">&quot;guests.html&quot;</span>) (<span class="hljs-name">look-guests/html</span>)]]
     (<span class="hljs-name"><span class="hljs-built_in">map</span></span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [post]
            [fs/delete-if-exists (<span class="hljs-name">html-path</span> (<span class="hljs-name">post/html-file-name</span> post))])
          post-to-delete))))

(<span class="hljs-keyword">defn</span> <span class="hljs-title">update!</span> [site]
  (<span class="hljs-name">run!</span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [[f &amp; args]] (<span class="hljs-name"><span class="hljs-built_in">apply</span></span> f args)) site))
</code></pre>
<p><code>classify-posts</code>는 블로그의 유일한 상태인 post 집합의 현재와 과거 스냅샷을 비교하여 변경이 없는 것, 삭제할 것, 수정/생성할 것으로 나눈다.</p>
<p><code>site</code> 함수에서는 이렇게 분류한 post들을 받는다. site는 이들(<code>xxx-posts</code> 등)을 받아서 html 파일(들)을 만드는 방법을 정의한다. 그 방법은 <code>update!</code>에서 처리할 수 있는 DSL(함수와 인자를 담은 벡터의 시퀀스)로 표현된다.</p>
<pre><code class="hljs">$ tree <span class="hljs-attribute">src</span>
<span class="hljs-attribute">src</span>
├── clj
│   └── kur
│       ├── blog
│       │   ├── look
│       │   │   ├── archive<span class="hljs-selector-class">.clj</span>
│       │   │   ├── error<span class="hljs-selector-class">.clj</span>
│       │   │   ├── guests<span class="hljs-selector-class">.clj</span>
│       │   │   ├── home<span class="hljs-selector-class">.clj</span>
│       │   │   ├── post<span class="hljs-selector-class">.clj</span>
│       │   │   ├── subscribe<span class="hljs-selector-class">.clj</span>
│       │   │   ├── tags<span class="hljs-selector-class">.clj</span>
│       │   │   └── template<span class="hljs-selector-class">.clj</span>
│       │   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.clj</span>
│       │   ├── monitor<span class="hljs-selector-class">.clj</span>
│       │   ├── obsidian
│       │   │   ├── frontmatter<span class="hljs-selector-class">.clj</span>
│       │   │   └── tag<span class="hljs-selector-class">.clj</span>
│       │   ├── page
│       │   │   ├── post
│       │   │   │   ├── diff<span class="hljs-selector-class">.clj</span>
│       │   │   │   ├── md2x<span class="hljs-selector-class">.clj</span>
│       │   │   │   └── name<span class="hljs-selector-class">.clj</span>
│       │   │   ├── post<span class="hljs-selector-class">.clj</span>
│       │   │   └── tags<span class="hljs-selector-class">.clj</span>
│       │   ├── policy<span class="hljs-selector-class">.clj</span>
│       │   ├── state<span class="hljs-selector-class">.clj</span>
│       │   └── updater<span class="hljs-selector-class">.clj</span>
</code></pre>
<p>home, archive 등 각각의 데이터와 페이지의 로직은 각각 <code>page</code>와 <code>look</code> 네임스페이스에서 정의한다. 예상했듯이, 이것들을 하나의 Publishable 프로토콜(인터페이스)로 묶을 이유가 전혀 없다.</p>
<p><code>src/clj/kur/blog/main.clj</code></p>
<pre><code class="hljs language-clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">-main</span> [config-path]
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [{<span class="hljs-symbol">:keys</span> [md-dir html-dir fs-wait-ms]
         <span class="hljs-symbol">:as</span> config} (<span class="hljs-name">load-config</span> <span class="hljs-symbol">:file</span> config-path)
        state (<span class="hljs-name"><span class="hljs-built_in">atom</span></span> (<span class="hljs-name">state/initial</span>))
        update! #(<span class="hljs-name">state/update!</span> state (<span class="hljs-name">state/current</span> @state config))]

    <span class="hljs-comment">;; Initialize</span>
    (<span class="hljs-name">uf/delete-all-except-gitkeep</span> html-dir)
    (<span class="hljs-name">update!</span>)

    <span class="hljs-comment">;; Monitor and Update</span>
    (<span class="hljs-name">monitor/monitor</span> update! fs-wait-ms md-dir)))
</code></pre>
<p>이 모든 과정에서 사이드 이펙트는 배제되어 있으며, 최종적으로 <code>main</code>과 <code>monitor</code>가 호출하는 <code>update!</code>에서 사이드 이펙트를 일으켜 html을 생성/수정/삭제한다.</p>
<h2 id="결론" tabindex="-1"><a class="only-cursor" href="#결론">결론</a></h2>
<p>(개인) 프로젝트를 위한 <strong>설계표현은 무조건 간결</strong>해야 한다.<br>
내 오랜 개인 프로젝트 경험 상 간결하지 않은 설계 표현은 없느니만 못하다.</p>
<p>얼마나 간결해야 하는가? <strong>미래의 내가 알아볼 수 있을 정도</strong>면 충분하다.<br>
개인 프로젝트의 협업자는 <em>과거, 현재, 미래의 나</em>이기 때문이다.</p>
<p><br>
그렇다면 여럿이서 할 때는? 그건 좀 더 해보고 이야기 해 줄게 ㅎㅎ</p>
</article><footer class="container"><div class="site-footer">Copyright 2023 KUR. All Rights Reserved.</div></footer></body></html>