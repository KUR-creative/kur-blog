<!DOCTYPE html>
<html><head><meta content="width=device-width, initial-scale=1" name="viewport"><meta charset="utf-8"><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3VM2LWXJF8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3VM2LWXJF8');
</script>
<link href="resource/site/k.png" rel="icon" type="image/x-icon"><link href="resource/site/css/layout.css" rel="stylesheet" type="text/css"><link href="resource/site/css/header.css" rel="stylesheet" type="text/css"><link href="resource/site/css/footer.css" rel="stylesheet" type="text/css"><link href="resource/site/css/article.css" rel="stylesheet" type="text/css"><link href="resource/site/css/anchor.css" rel="stylesheet" type="text/css"><link href="resource/site/css/highlight_fragment.css" rel="stylesheet" type="text/css"><title>(OLD) Q. 혹시 그러면 코드를 짤 때 설계도를 그리는 방법론에 관해서 작성자님의 생각과 비슷하거나 혹은 작성자님이 추천해주시는 컨텐츠가 있을까요??</title></head><body><header class="container"><hr><div class="site-title"><a class="only-cursor" href="/">KUR Creative</a></div><hr><nav class="navigation"><a class="only-cursor" href="archive">archive</a><a class="only-cursor" href="series">series</a><a class="only-cursor" href="tags">tags</a><a class="only-cursor" href="subscribe">subscribe</a><a href="https://www.google.com/search?q=site%3Ablog.kurcreative.com+공사중.."><img height="20px" src="resource/site/search.png" width="20px"></a></nav><hr></header><article class="container"><h1>(OLD) Q. 혹시 그러면 코드를 짤 때 설계도를 그리는 방법론에 관해서 작성자님의 생각과 비슷하거나 혹은 작성자님이 추천해주시는 컨텐츠가 있을까요??</h1><blockquote>
<p>주의) (<mark><strong>OLD</strong></mark>)로 표기된 글은 현재 제 생각과 크게 다르거나 <mark>중대한 오류</mark>가 있지만<br>
아카이브용으로 유지하는 글입니다</p>
</blockquote>
<blockquote>
<p><a href="kur2012151553.+.고전적 소프트웨어 공학(좆같은 UML 그리기)의 단점">이전 글</a>의 <a href="https://m.blog.naver.com/CommentList.naver?blogId=rhdnfka94&amp;logNo=222231414763">과거 블로그 댓글</a> 중 첫 댓글의 질문에 답하는 내용입니다</p>
</blockquote>
<p><br>
<br>
A.<br>
저는 혼자서 개발하기 때문에 UML이 나쁘다고 했지만,<br>
협업하는 사람들 다수가 UML을 어느 정도 안다면 꽤나 좋은 의사 소통 수단이 될 거라고 생각합니다.<br>
가볍게 쓰면 괜찮다고 봐요.</p>
<p><br>
저도 어떤 방법이 프로그램의 올바른 설계 표현인지 아직 찾고 있어서 어떤 명확한 답을 드리기는 어렵네요.<br>
이게 문제마다 다르고 참여자마다 달라서 어디에나 적용 가능한 은총알을 찾을 수는 없다고 봐요.</p>
<p>저도 여러모로 시도를 해 보고 있습니다.<br>
프로그램 설계라는 게 다른 공학의 설계도처럼 명확하게 표준이나 올바른 방법이 있지 않아서<br>
아직 다들 본인에게 맞는 걸 찾아야 한다고 생각합니다.</p>
<p><br>
먼저<br>
WHAT: 설계 표현에 무엇이 있어야하는지, 설계 활동에서 무엇을 해야 하는지 설명드리고<br>
HOW: 그래서 설계 표현은 어떻게 표현되어야하는지 이야기해보겠습니다.<br>
그리고 팁 몇가지를 소개드리는 걸로...</p>
<h2 id="WHAT" tabindex="-1"><a class="only-cursor" href="#WHAT">WHAT</a></h2>
<h3 id="Hammock-Driven-Development" tabindex="-1"><a class="only-cursor" href="#Hammock-Driven-Development">Hammock Driven Development</a></h3>
<p><em>설계 방법론, 설계로 무엇을 해야하는지</em>는 Rich Hickey의 해먹 주도 개발 Hammock Driven Development에 영향을 많이 받았습니다.<br>
<a href="https://youtu.be/f84n5oFoZBc">영상|embed</a><br>
스크립트: <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/HammockDrivenDev.md">https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/HammockDrivenDev.md</a></p>
<p>그의 말을 요약하자면 프로그래밍은 문제를 푸는 행위이고,<br>
설계 문서는 문제 해결에 도움이 되는 방향으로 작성해야한다는 것입니다.<br>
영상을 보시면 큰 도움이 되리라 생각합니다.</p>
<h3 id="Design,-Composition,-and-Performance" tabindex="-1"><a class="only-cursor" href="#Design,-Composition,-and-Performance">Design, Composition, and Performance</a></h3>
<p>리치 히키의 다른 영상(디자인, 컴포지션, 퍼포먼스)에서도 설계에 대한 이야기가 좀 나옵니다.<br>
<a href="https://youtu.be/MCZ3YgeEUPg">영상|embed</a><br>
스크립트: <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/DesignCompositionPerformance.md">https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/DesignCompositionPerformance.md</a></p>
<h3 id="Bottom-Up-vs-Top-Down-Design-in-Clojure-or-API-First-vs-Data-First-Design-in-Clojure" tabindex="-1"><a class="only-cursor" href="#Bottom-Up-vs-Top-Down-Design-in-Clojure-or-API-First-vs-Data-First-Design-in-Clojure">Bottom Up vs Top Down Design in Clojure or API First vs Data First Design in Clojure</a></h3>
<p>또한 바텀-업 사고 방식에 대한 생각은 다음 영상에서 영향을 받았습니다.<br>
<a href="https://www.youtube.com/watch?v=Tb823aqgX_0">Bottom Up vs Top Down Desion in Clojure|embed</a></p>
<h3 id="How-to-Solve-It" tabindex="-1"><a class="only-cursor" href="#How-to-Solve-It">How to Solve It</a></h3>
<p>문제 해결에 대한 책은 아주 유명한 G. Polya의 How to Solve It을 좀 보았습니다.<br>
<img src="resource/How to Solve it.jpg" alt="resource/How to Solve it.jpg"><br>
<a href="https://en.wikipedia.org/wiki/How_to_Solve_It">https://en.wikipedia.org/wiki/How_to_Solve_It</a><br>
<a href="http://www.yes24.com/Product/Goods/325507">http://www.yes24.com/Product/Goods/325507</a></p>
<p>이 책은 리치 히키의 해먹 주도 개발 영상에서도 소개되는데, 직접 보니까 내용이 좋더라구요.</p>
<h2 id="HOW" tabindex="-1"><a class="only-cursor" href="#HOW">HOW</a></h2>
<blockquote>
<p><mark>주의: 이 문단의 내용은 23년 현재의 제가 보기엔 심각한 오류가 있습니다</mark><br>
이 글에 대한 비판과 23년 현재 설계에 대한 제 생각은 [여기]서 확인해 주세요</p>
</blockquote>
<p>설계 표현은 여러가지 시도를 해 보았습니다.</p>
<p>처음에는 구글 닥스에 하다가 링크 기능이 부족해서 노션을 썼습니다.<br>
그런데 노션은 문단 접기 기능이 너무 부실해서(로딩이 너무 느립니다) 다른 걸 찾게 되었습니다.</p>
<p>그러다가 생각을 정리하는 방법론으로 Zettelkasten이라는 방법을 알게 되었고,<br>
<a href="https://tkim.co/2020/09/15/zettelkasten/">https://tkim.co/2020/09/15/zettelkasten/</a></p>
<p>이걸 프로그램 설계 표현에 적용하려 노력해보았습니다.<br>
그래서 Obsidian이란 프로그램을 한동안 썼는데, 그래프 연결 단위가 문서인데다가<br>
블록 인용 기능이 너무 구리고 테이블 기능이 불편해서 결국 RoamResearch로 갈아 탔습니다.</p>
<p>롬리서치는 꽤 괜찮지만 아직도 제가 생각하는 이상적인 설계 표현은 아닙니다.<br>
결국 저는 제가 원하는 설계 표현을 위한 툴을 직접 만들게 될 것 같습니다.<br>
<a href="kur2101231411.+.(OLD) 소프트웨어 개발을 위한 지식 기반 시스템 Knowledge Base System for Software Development">kur2101231411.+.(OLD) 소프트웨어 개발을 위한 지식 기반 시스템 Knowledge Base System for Software Development</a></p>
<p>다이어그램 툴로는 draw.io를 씁니다. 공짜인데다 그냥 잘 작동하고 iframe을 통한 임베딩도 잘 됩니다!</p>
<h2 id="Tips" tabindex="-1"><a class="only-cursor" href="#Tips">Tips</a></h2>
<p>설계에 대해서 하고픈 말도 많고 아직도 무엇이 올바른 방법인지 계속 찾고 있습니다.<br>
당장 떠오르는 것들만 써볼게요.</p>
<ul>
<li>프로그래밍은 문제 해결 과정이어야 하며, 프로그램은 문제의 해답입니다.</li>
<li>해답을 만들기 전에 문제를 잘 알아야 하며, 설계는 문제를 풀기 위한 노력의 일환입니다.</li>
<li>문제를 잘 모르고 만든 해답은 문제를 해결하는 게 아니라 또 다른 문제를 만들 수 있습니다.<br>
그렇기에 문제 해결(프로그래밍)에 앞서 문제를 잘 알아야(설계, 다양한 활동) 합니다.</li>
</ul>
<p><img src="resource/아는_것을_알기_테이블.png" alt="resource/아는_것을_알기_테이블.png"></p>
<ul>
<li>문제 해결을 위해서는 우리가 &quot;아는 것&quot;과 &quot;모르는 것&quot;을 파악해야 합니다.</li>
<li>아직 &quot;모르는 것&quot;에 대해 알아가기 위해 의식적인 활동을 해야 합니다.</li>
<li>설계 표현은 문제에 대한 표현과, 현재 우리 지식에 대한 표현도 포함해야 합니다.</li>
</ul>
<p>그 글에서 말은 안 했지만 과거 설계 표현에는 이러한 &quot;지식의 상태&quot;에 대한 명시적 표현이 없습니다.<br>
그 또한 큰 문제라고 생각합니다.</p>
<ul>
<li>설계 표현은 유지보수되어야 하며 반복적으로 작성되어야 합니다.</li>
<li>프로그램 코드는 반드시 설계를 반영하고 설계에 의존해야 합니다.</li>
<li>뭔가 새로 알았거나 요구사항이 변해서 프로그램이 변경될 경우,<br>
반드시 설계를 먼저 수정하고 나서 그에 맞춰 프로그램을 수정해야 합니다.<br>
설계가 프로그램에 의존할 경우 설계는 시간 낭비가 됩니다.</li>
</ul>
<p>생각의 표현</p>
<ul>
<li>해답은 하나 이상 내야 합니다. 그리고 문제를 해결하는지 확인해야 합니다.</li>
<li>여러 해답의 장단점 비교, 다양한 사실의 비교, 구체화 등에 테이블이 유용합니다.</li>
<li>사실의 구체화, 문제의 분해를 표현하는데 트리 구조의 다이어그램이 유용합니다.</li>
<li>사실들의 연관관계를 표현하는데는 그래프 구조가 유용합니다.</li>
<li>그 외에도 &quot;가벼운 UML&quot;을 쓰는 것은 도움이 됩니다. 저도 몇개 그려보았습니다.</li>
<li>그리고 그냥 머리속에 뭔가 있다 싶으면 표현에 상관 없이 그림을 그려보면 분명히 도움이 됩니다.<br>
설계 문서로 기록해두지 않고 그냥 그리고 버려도 도움이 됩니다. 그러다 필요하면 저장하구요.</li>
</ul>
<p><br>
이 블로그에도 여러번 포스팅을 올렸습니다.ㅓ<br>
가능하면 강연 원본을 보시면 좋겠습니다. 정말 많은 도움이 된 영상들입니다.</p>
<p>글이 넘 길어졌네요 ㅋ<br>
도움이 되었으면 합니다.</p>
<p><br>
<a href="https://m.blog.naver.com/CommentList.naver?blogId=rhdnfka94&amp;logNo=222231414763">과거 블로그 댓글</a></p>
<p>사실 위 댓글 쓴 사람의 질문에 대답하는 글이다. <a href="kur2012151553.+.고전적 소프트웨어 공학(좆같은 UML 그리기)의 단점">이전 글</a></p>
<div class="tags-pane"><a class="tag" href="tags#from/old-blog">#from/old-blog</a><a class="tag" href="tags#sw-design설계">#sw-design설계</a><a class="tag" href="tags#fallacy틀린글">#fallacy틀린글</a></div><div class="post-link-pane"><a class="hover-link" href="kur2101231411">kur2101231411</a><a class="hover-link" href="archive#kur2102041115">Archive</a><a class="hover-link" href="kur2102202026">kur2102202026</a></div></article><footer class="container"><div class="site-footer">Copyright 2023 KUR. All Rights Reserved.</div></footer></body></html>